as.matrix()
eu1_names = rownames(eu1)
eu1_gd <- matrix(as.numeric(eu1), nrow = dim(eu1)[1])
colnames(eu1) <- rownames(eu1) <- names
<- names
names
colnames(eu1) <- rownames(eu1)
eu1[1:4,1:4]
class(eu1)
#------
na1 <- read.csv("na1_gendists_snpsubset.txt", header = T, sep = " ") |>
as.matrix()
na1_names = rownames(na1)
na1_gd <- matrix(as.numeric(na1), nrow = dim(na1)[1])
colnames(na1) <- rownames(na1) <- names
colnames(na1) <- rownames(na1)
na1[1:4,1:4]
class(na1)
#----- loading SOD metadata
data <- read.csv("hazel_population_data.csv")
dim(data)
data.wgs <- read.csv("hazel_population_data.wgs.csv")
dim(data.wgs)
#' subsetting data sets
dat = data.wgs[data$ID %in% data.wgs$ID,]
dat
# ploting distances subset VCF 10% using ______
par(mfrow = c(1,2))
hist(eu1[eu1 > 0], xlim = c(0,0.35), breaks = 100)
hist(na1[na1 > 0], xlim = c(0,0.35), breaks = 100)
# recalculating distances
## function to keep the same distance
eq <- function(x) (x*1)
#
eu1_mac_tre <- aboot(as.matrix(eu1), dist = eq ,
sample = 100, showtree = T, tree = "nj", )
# recalculating distances
na1_mac_tre <- aboot(as.matrix(na1), dist = eq ,
sample = 100, showtree = T, tree = "nj")
# subsetting by year
# using library("treeman") for method ___________ et al. 202?
y1 <- dat |>
subset(Year == 2016 & ID %in% eu1_mac_tre$tip.label)|>
select(ID, Year)
y2 <- dat |>
subset(Year == 2017 & ID %in% eu1_mac_tre$tip.label)|>
select(ID, Year)
y3 <- dat |>
subset(Year == 2018 & ID %in% eu1_mac_tre$tip.label)|>
select(ID, Year)
y4 <- dat |>
subset(Year == 2019 & ID %in% eu1_mac_tre$tip.label)|>
select(ID, Year)
# get data by ID for
datos <- dat |>
subset( ID %in% eu1_mac_tre$tip.label)
xmatrix = matrix(0, ncol = 5, nrow = nrow(datos))
for (i in 1:nrow(datos)){
xmatrix[i,1] <- datos[i,1]
xmatrix[i,2] <- ifelse(datos[i,1] %in% y1$ID, yes = 1, no = 0)
xmatrix[i,3] <- ifelse(datos[i,1] %in% y2$ID, yes = 1, no = 0)
xmatrix[i,4] <- ifelse(datos[i,1] %in% y3$ID, yes = 1, no = 0)
xmatrix[i,5] <- ifelse(datos[i,1] %in% y4$ID, yes = 1, no = 0)
}
rownames(xmatrix) <- xmatrix[,1]
xmatrix <- xmatrix[,c(2:5)] |>
t()
xmatrix <- apply(xmatrix, 2, FUN=as.numeric)
rownames(xmatrix) <- c(2016, 2017, 2018, 2019)
head(xmatrix)
# NA1
y1 <- dat |>
subset(Year == 2001 & ID %in% na1_mac_tre$tip.label)|>
select(ID, Year)
y2 <- dat |>
subset(Year == 2002 & ID %in% na1_mac_tre$tip.label)|>
select(ID, Year)
y3 <- dat |>
subset(Year == 2003 & ID %in% na1_mac_tre$tip.label)|>
select(ID, Year)
y4 <- dat |>
subset(Year == 2004 & ID %in% na1_mac_tre$tip.label)|>
select(ID, Year)
y5 <- dat |>
subset(Year == 2005 & ID %in% na1_mac_tre$tip.label)|>
select(ID, Year)
datos <- dat |>
subset( ID %in% na1_mac_tre$tip.label)
ymatrix = matrix(0, ncol = 6, nrow = nrow(datos))
for (i in 1:nrow(datos)){
ymatrix[i,1] <- datos[i,1]
ymatrix[i,2] <- ifelse(datos[i,1] %in% y1$ID, yes = 1, no = 0)
ymatrix[i,3] <- ifelse(datos[i,1] %in% y2$ID, yes = 1, no = 0)
ymatrix[i,4] <- ifelse(datos[i,1] %in% y3$ID, yes = 1, no = 0)
ymatrix[i,5] <- ifelse(datos[i,1] %in% y4$ID, yes = 1, no = 0)
ymatrix[i,6] <- ifelse(datos[i,1] %in% y5$ID, yes = 1, no = 0)
}
rownames(ymatrix) <- ymatrix[,1]
ymatrix <- ymatrix[,c(2:6)] |>
t()
ymatrix <- apply(ymatrix, 2, FUN=as.numeric)
rownames(ymatrix) <- c(2001, 2002, 2003, 2004, 2005)
head(ymatrix)
#-------
# retrieving branch length using the Grafen method:
#                                    setting the ages of nodes equal to one less than
#                                    the number of species arising from that node
# EU1
eu1_tree <- compute.brlen(eu1_mac_tre, method = "Grafen")
eu1_tree$edge.length <- eu1_tree$edge.length/getSize(eu1_tree, "rtt")
plot(eu1_tree, cex=0.4)
# NA1
na1_tree <- compute.brlen(na1_mac_tre, method = "Grafen")
na1_tree$edge.length <- na1_tree$edge.length/getSize(na1_tree, "rtt")
plot(na1_tree, cex=0.4)
# branch length distance from-to network
eu1_gdnet <- as.data.frame(eu1_tree$edge) # original entry eu1_mac_tre$edge
eu1_gdnet$length <- as.numeric(eu1_tree$edge.length)
colnames(eu1_gdnet) <- c("From", "To", "value")
commplot(xmatrix, eu1_mac_tre, groups=c(1:4), no.margin=TRUE)
# branch length distance from-to network
na1_gdnet <- as.data.frame(na1_tree$edge) # original entry
na1_gdnet$length <- as.numeric(na1_tree$edge.length)
colnames(na1_gdnet) <- c("From", "To", "value")
commplot(ymatrix, na1_mac_tre, groups=c(1:5), no.margin=TRUE, )
# plotting branch length distances
par(mfrow=c(1,2))
hist(eu1_gdnet$value, breaks= 100, xlim = c(0,0.125))
abline(v=0.07, col="red")
hist(na1_gdnet$value, breaks= 100, xlim = c(0,0.125))
abline(v=0.07, col="red")
dev.off()
#--------------------------------
#----- Network
x = eu1_gdnet
y = na1_gdnet
GRPHx <- graph_from_data_frame(x, directed = FALSE)
GRPHy <- graph_from_data_frame(y, directed = FALSE)
# adding colors and attributes
rbPal <- colorRampPalette(c("grey", "black"))
counPal <- colorRampPalette(c("red", "yellow", "blue", "white", "brown"), bias = 1)
V(GRPHx)$size=5
V(GRPHy)$size=5
yearx <- dat[which(dat$ID %in% eu1_tree$tip.label),]|>
select(Year) |>
unlist() |>
as.numeric() # make the categories of x into numeric values for color ramp
V(GRPHx)$year <- yearx
V(GRPHx)$color <- counPal(10)[cut(as.numeric(V(GRPHx)$year),breaks = 10)]
CounColorx <- unique(cbind(V(GRPHx)$year, V(GRPHx)$color))
yeary <- dat[which(dat$ID %in% na1_mac_tre$tip.label),]|>
select(Year) |>
unlist() |>
as.numeric() # make the categories of x into numeric values for color ramp
V(GRPHy)$year <- yeary
V(GRPHy)$color <- counPal(10)[cut(as.numeric(V(GRPHy)$year),breaks = 10)]
CounColory <- unique(cbind(V(GRPHy)$year, V(GRPHy)$color))
E(GRPHx)$xx <- x$value # make the categories of x into numeric values for color ramp
#--------------------------------
#----- Network
x = eu1_gdnet
y = na1_gdnet
GRPHx <- graph_from_data_frame(x, directed = FALSE)
GRPHy <- graph_from_data_frame(y, directed = FALSE)
# adding colors and attributes
rbPal <- colorRampPalette(c("grey", "black"))
counPal <- colorRampPalette(c("red", "yellow", "blue", "white", "brown"), bias = 1)
V(GRPHx)$size=5
V(GRPHy)$size=5
yearx <- dat[which(dat$ID %in% eu1_tree$tip.label),]|>
select(Year) |>
unlist() |>
as.numeric() # make the categories of x into numeric values for color ramp
V(GRPHx)$year <- yearx
yearx
V(GRPHx)$color <- counPal(10)[cut(as.numeric(V(GRPHx)$year),breaks = 10)]
CounColorx <- unique(cbind(V(GRPHx)$year, V(GRPHx)$color))
yeary <- dat[which(dat$ID %in% na1_mac_tre$tip.label),]|>
select(Year) |>
unlist() |>
as.numeric() # make the categories of x into numeric values for color ramp
V(GRPHy)$year <- yeary
V(GRPHy)$color <- counPal(10)[cut(as.numeric(V(GRPHy)$year),breaks = 10)]
CounColory <- unique(cbind(V(GRPHy)$year, V(GRPHy)$color))
E(GRPHx)$xx <- x$value # make the categories of x into numeric values for color ramp
E(GRPHy)$xx <- y$value # make the categories of x into numeric values for color ramp
# ploting branch lenght
par(mfrow=c(1,2))
hist(E(GRPHx)$xx, breaks= 100, xlim = c(0,0.1))
abline(v=0.08, col="red")
hist(E(GRPHy)$xx, breaks= 100, xlim = c(0,0.1))
abline(v=0.08, col="red")
dev.off()
# Select conditionals
condx  <- E(GRPHx)[E(GRPHx)$xx >  0.08]
condy  <- E(GRPHy)[E(GRPHy)$xx >  0.08]
# Remove edges nodes
GRPHx <- delete.edges(GRPHx, condx)
GRPHy <- delete.edges(GRPHy, condy)
E(GRPHx)$color <- rbPal(10)[cut(as.numeric(E(GRPHx)$xx),breaks = 10)]
E(GRPHy)$color <- rbPal(10)[cut(as.numeric(E(GRPHy)$xx),breaks = 10)]
plot(GRPHx,  edge.arrow.size=.05, vertex.label.cex=.3, vertex.label.color='black',
edge.curved = F, edge.width=1, layout=layout_with_fr)
legend(x= 0.9, y= -0.9, legend = CounColorx[,1], pch=21,  col="black", pt.bg=CounColorx[,2], pt.cex=2,cex=.8, bty="n", ncol=1)
plot(GRPHy,  edge.arrow.size=.05, vertex.label.cex=.3, vertex.label.color='black',
edge.curved = F, edge.width=1, layout=layout_with_fr)
legend(x= 0.9, y= -0.9, legend = CounColory[,1], pch=21,  col="black", pt.bg=CounColory[,2], pt.cex=2,cex=.8, bty="n", ncol=1)
eu1_net <- make_network(eu1_tree, distance=eu1, max.dist = 0.01)
#-------------------------------------------------------------
# https://web.stanford.edu/class/bios221/book/Chap-Graphs.html
#-------------------------------------------------------------
library(phyloseq)
eu1_net <- make_network(eu1_tree, distance=eu1, max.dist = 0.01)
eu1_tree
class(eu1_tree)
eu1_net <- make_network(eu1_tree, distance=eu1, max.dist = 0.01)
eu1
eu1
eu1[1]
eu1
as.matrix(eu1)
as.data.frame(eu1)
as.matrix(as.data.frame(eu1))
class(as.matrix(as.data.frame(eu1)))
class(matrix(as.data.frame(eu1)))
matrix(as.data.frame(eu1))
as.data.frame(eu1)
class(eu1)
unlist(eu1)
c(eu1)
dim(eu1)
matrix(c(eu1), nrow = 160)
class(matrix(c(eu1), nrow = 160))
is.na(c(eu1), nrow = 160)
is.na(eu1)
table(is.na(eu1))
is.character(eu1)
is.na(eu1)
(eu1)
is.numeric(eu1)
is.array(eu1)
eu1
str(eu1)
c(eu1)
eu1dat <- c(eu1)
eu1dat
matrix(eu1dat, nrow = 160)
eu1mat <- matrix(eu1dat, nrow = 160)
class(eu1mat)
eu1dat
as.matrix(eu1dat)
as.matrix(eu1dat, nrow=160)
matrix(eu1dat, byrow = 160)
matrix(eu1dat, ncol =  = 160)
matrix(eu1dat, ncol = 160)
eu1mat <- matrix(eu1dat, ncol = 160)
eu1mat
class(eu1mat)
write.csv("eu1_mat.csv", eu1mat)
write.csv("eu1_mat.csv", eu1)
write.csv("eu1_mat.csv", eu1)
eu1_mat.csv
write.csv("eu1_mat.csv", eu1)
write.csv("eu1_mat.csv", eu1$1)
eu1$1
eu1[[1]]
eu1[[2]]
eu1[[]][1]
eu1[[1]][1]
eu1[[1]][2]
eu1[1][[1]]
eu1[2][[1]]
eu1[2]
eu1@1
eu1@2
eu1$1
eu1
str(eu1)
num(eu1)
eu1num <- num(eu1)
eu1num
c(eu1num)
eu1num
aver=eu1num
aver
as.matrix(aver)
matrix(aver)
matrix(aver, nrow=160)
eu1mat <- matrix(aver, nrow=160)
class(eu1mat)
str(eu1mat)
eu1_net <- make_network(eu1_tree, distance= eu1mat, max.dist = 0.0)
eu1mat
eu1_net <- make_network(eu1_tree, distance= eu1mat, max.dist = 0.01)
eu1_net <- make_network(eu1_tree, distance= eu1, max.dist = 0.01)
eu1
eu1_net <- make_network(eu1_tree, distance= eu1, max.dist = 0.01)
taxa_are_rows(eu1)
eu1
eu1
str(eu1)
phyloseq(eu1)
taxa_names(eu1)
taxa_names(eu1) <-  rownames(eu1)
taxa_names(eu1)
taxa_names(eu1)
?taxa_names()
eu1
eu1_tree
phy_tree(eu1_tree)
otu_table(eu1_tree)
otu_table(dat)
?otu_table()
data("esophagus")
esophagus
otu_table(esophagus)
dat
rownames(dat) <- dat$ID
dat
otu_table(dat)
#' subsetting data sets
devtools::install_github("jbisanz/qiime2R")
rownames(dat) <- dat$ID
dat <- otu_table(dat, taxa_are_rows = T)
tax_table(dat)
dat <- tax_table(dat)
dat
#----- loading SOD metadata
data <- read.csv("hazel_population_data.csv")
#----- loading SOD metadata
data <- read.csv("hazel_population_data.csv")
#----- loading SOD metadata
data <- read.csv("hazel_population_data.csv")
#----- loading SOD metadata
data <- read.csv("hazel_population_data.csv")
#----- loading SOD metadata
data <- read.csv("hazel_population_data.csv")
dim(data)
data.wgs <- read.csv("hazel_population_data.wgs.csv")
dim(data.wgs)
#' subsetting data sets
dat = data.wgs[data$ID %in% data.wgs$ID,]
dat
rownames(dat) <- dat$ID
dat
tax <- tax_table(dat)
taxa_are_rows(tax)
phyloseq(tax, eu_tree)
phyloseq(tax, eu1_tree)
eu1_tree
eu1
eu1_tree
eu1_tree
eu1_tree$node.label
eu1_tree$edge.length
eu1_tree$tip.label
str(eu1_tree)
class(eu1_tree)
as.network(eu1_tree)
#-------------------------------------------------------------
# https://web.stanford.edu/class/bios221/book/Chap-Graphs.html
#-------------------------------------------------------------
library(ape)
as.network(eu1_tree)
install.packages("ape")
install.packages("ape")
install.packages("ape")
install.packages("ape")
#-------------------------------------------------------------
# https://web.stanford.edu/class/bios221/book/Chap-Graphs.html
#-------------------------------------------------------------
library(ape)
as.network(eu1_tree)
as.network.phylo()
as.network.phylo(eu1_tree)
as.network.phylo(eu1_tree)
as.network.phylo(eu1_tree, directed = directed)
as.network(eu1_tree, directed = )
as.network.evonet(eu1_tree)
?as.network.evonet
evonet(eu1_tree,directed = )
evonet(eu1_tree,directed = directed)
evonet(eu1_tree)
evonet(eu1_tree, from = NULL)
evonet(eu1_tree, from = NULL, directed = F)
evonet(eu1_tree, from = NULL, directed = FALSE)
evonet(eu1_tree, from = NULL)
tr <- rcoal(5)
tr
(x <- evonet(tr, 6:7, 8:9))
plot(x)
## simple example of extended Newick format:
(enet <- read.evonet(text = "((a:2,(b:1)#H1:1):1,(#H1,c:1):2);"))
plot(enet, arrows=1)
## from Fig. 2 in Cardona et al. 2008:
z <- read.evonet(text =
"((1,((2,(3,(4)Y#H1)g)e,(((Y#H1, 5)h,6)f)X#H2)c)a,((X#H2,7)d,8)b)r;")
z
plot(z)
## Not run:
if (require(igraph)) {
plot(as.igraph(z))
}
plot(x)
tr <- rcoal(5)
(x <- evonet(tr, 6:7, 8:9))
evonet
x
evonet(eu1_tree)
que <- evonet(eu1_tree)
que
que <- evonet(eu1_tree, from = NULL)
eu1
que <- evonet(eu1_tree, from = eu1)
eu1
que <- evonet(eu1_tree, from = eu1)
eu1_tree$edge
que <- evonet(eu1_tree, from = eu1_tree$edge)
is.rooted(eu1_tree)
unroot(eu1_tree)
(eu1_tree)
que <- evonet(eu1_tree, from = eu1_tree$edge, root = unrooted)
que <- evonet(eu1_tree, from = eu1_tree$edge, root = "unrooted")
que <- evonet(eu1_tree, from = eu1_tree$edge, root = F)
que <- evonet(eu1_tree, from = eu1_tree$edge)
que
plot(que)
read.evonet(que)
as.igraph(que)
as.igraph(que,directed = F)
as.igraph(que,directed = F, use.labels = tax)
as.igraph(que,directed = F, use.labels = eu1_tree$edge)
as.igraph(que, directed = F)
as.igraph(que, directed = F,use.labels = )
?as.igraph
as.igraph(que, directed = is.rooted(que), use.labels = TRUE)
as.igraph(que, directed = F, use.labels = TRUE)
as.igraph(que, directed = FALSE, use.labels = TRUE)
as.igraph(que,directed = F)
as.igraph(que, directed = FALSE, use.labels = TRUE)
as.igraph(que,directed = F, use.labels = eu1_tree$edge)
as.igraph(que,directed = F, use.labels = tax)
as.igraph(que,directed = F, use.labels = T)
as.igraph(eu1_tree,directed = F, use.labels = T)
as.igraph(eu1_tree,directed = F, use.labels = F)
calc(eu1_tree)
as.igraph(eu1_tree,directed = F, use.labels = F)
library(treeman)
calc(eu1_tree)
treeman::calcFrPrp(eu1_tree)
treeman::calcFrPrp(eu1_tree$edge.length)
treeman::calcFrPrp(eu1)
treeman::calcFrPrp(eu1_mac_tre)
treeman::calcFrPrp(eu1_tree)
plot(eu1_tree, cex=0.4)
treeman::calcFrPrp(eu1_mac_tre)
?calcFrPrp
treeman::calcFrPrp(eu1_mac_tre,tids = eu1_mac_tre$tip.label)
treeman::calcFrPrp(eu1_mac_tre$edge.length,tids = eu1_mac_tre$tip.label)
treeman::calcFrPrp(eu1_mac_tre$Nnode,tids = eu1_mac_tre$tip.label)
treeman::calcFrPrp(eu1_mac_tre$node.label,tids = eu1_mac_tre$tip.label)
library(treeman)
tree <- randTree(10)
calcFrPrp(tree, tree['tips'])
library(treeman)
tree <- randTree(10)
tree
str(tree)
treeman
?treeman
as(eu1_tree, 'TreeMen')
as(eu1_tree, 'TreeMea')
as(eu1_tree, 'TreeMan')
trees <- as(eu1_tree, 'TreeMan')
trees
eu1_trees <- as(eu1_tree, 'TreeMan')
treeman::calcFrPrp(eu1_trees, eu1_trees['tips'])
?calcNdsBlnc
#eu1_trees <- as(eu1_tree, 'TreeMan')
treeman::calcNdsBlnc(eu1_tree, eu1_trees['nds'])
#eu1_trees <- as(eu1_tree, 'TreeMan')
treeman::calcNdsBlnc(eu1_trees, eu1_trees['nds'])
?as.igraph()
data(bird.orders)
hc <- as.hclust(bird.orders)
tr <- as.phylo(hc)
all.equal(bird.orders, tr) # TRUE
tr
### shows the three plots for tree objects:
dend <- as.dendrogram(hc)
layout(matrix(c(1:3, 3), 2, 2))
plot(bird.orders, font = 1)
dev.off()
plot(bird.orders, font = 1)
commplot(xmatrix, eu1_mac_tre, groups=c(1:4), no.margin=TRUE, font = 1)
# branch length distance from-to network
eu1_gdnet <- as.data.frame(eu1_tree$edge) # original entry eu1_mac_tre$edge
eu1_gdnet$length <- as.numeric(eu1_tree$edge.length)
colnames(eu1_gdnet) <- c("From", "To", "value")
commplot(xmatrix, eu1_mac_tre, groups=c(1:4), no.margin=TRUE, font = 1)
# library(TreeTools)
# library(dendextend)
library("treeman")
library(MoreTreeTools)
library (devtools)
install_github ('DomBennett/MoreTreeTools')
library (devtools)
install_github ('DomBennett/MoreTreeTools', force = T)
# library(TreeTools)
# library(dendextend)
library("treeman")
library(MoreTreeTools)
